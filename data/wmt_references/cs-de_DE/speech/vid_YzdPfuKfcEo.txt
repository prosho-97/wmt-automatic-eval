Aber dann müsst ihr wissen, wie groß das Bild eigentlich ist. Ihr braucht irgendein Bild, ihr wollt es skalieren, damit das Seitenverhältnis erhalten bleibt – nur wisst ihr das anfangs nicht. Also müsst ihr `image.onload` setzen – eine Funktion, die herausfindet, wie groß das Bild tatsächlich ist. Erst wenn das Bild geladen ist, könnt ihr damit arbeiten.
Und genau auf dieses `onload` vergesst ihr dann, weil euch das in dem Moment gar nicht interessiert – es ist ja nur ein One-Shot. Ihr gebt einfach dem Bild die Eigenschaft `onload`, ohne einen Event Listener zu benutzen, weil ihr wisst, dass es euer Bild ist, und ihr nur wissen wollt, wie groß es ist.
Und genau das ist die Quelle für einen Memory Leak. Denn diese Referenz bleibt erhalten, selbst wenn ihr das Bild aus dem DOM entfernt – der Leak ist da. Was ich so beobachtet habe: Man sollte wirklich konsequent auf jeden angehängten Listener achten. Wenn die Anwendung lange laufen soll, muss man darauf achten, solche Listener auch wieder zu entfernen. Im Fall von `onload` reicht es z. B., `onload = null` zu setzen – damit entfernt ihr den Listener und verhindert den Leak.
